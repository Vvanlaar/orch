<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orch Dashboard</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0d1117; color: #c9d1d9; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; }
    h1 { font-size: 24px; font-weight: 600; }
    h2 { font-size: 16px; font-weight: 600; padding: 16px; border-bottom: 1px solid #30363d; }
    .status { display: flex; align-items: center; gap: 8px; font-size: 14px; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #3fb950; }
    .status-dot.disconnected { background: #f85149; }

    progress { appearance: none; border-radius: 4px; overflow: hidden; }
    progress::-webkit-progress-bar { background: #21262d; border-radius: 4px; }
    progress.bright::-webkit-progress-value { background: #58a6ff; }
    progress.dim::-webkit-progress-value { background: #484f58; }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 24px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }

    .card { background: #161b22; border: 1px solid #30363d; border-radius: 6px; overflow: hidden; }
    .card-list { max-height: 400px; overflow-y: auto; }

    .item { display: grid; grid-template-columns: 1fr auto; gap: 12px; padding: 12px 16px; border-bottom: 1px solid #21262d; align-items: center; }
    .item:hover { background: #1c2128; }
    .item-info { overflow: hidden; }
    .item-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 14px; }
    .item-meta { font-size: 12px; color: #8b949e; margin-top: 4px; display: flex; gap: 12px; flex-wrap: wrap; }
    .item-link a { color: #58a6ff; text-decoration: none; font-size: 13px; white-space: nowrap; }
    .item-link a:hover { text-decoration: underline; }

    .badge { font-size: 11px; padding: 2px 8px; border-radius: 12px; }
    .badge.state { background: #30363d; color: #8b949e; }
    .badge.state-active, .badge.state-open { background: #3fb95020; color: #3fb950; }
    .badge.state-new { background: #58a6ff20; color: #58a6ff; }
    .badge.state-resolved, .badge.state-closed { background: #8b949e20; color: #8b949e; }
    .badge.role-author { background: #a371f720; color: #a371f7; }
    .badge.role-reviewer { background: #f0883e20; color: #f0883e; }
    .badge.type { background: #21262d; color: #8b949e; }
    .badge.type-bug { background: #f8514920; color: #f85149; }
    .badge.type-feature, .badge.type-story { background: #3fb95020; color: #3fb950; }
    .badge.type-task { background: #58a6ff20; color: #58a6ff; }

    .empty { padding: 48px; text-align: center; color: #8b949e; }

    .tasks { margin-bottom: 24px; overflow-x: hidden; }
    .task { display: grid; grid-template-columns: 60px 90px minmax(0, 1fr) 80px auto; gap: 12px; padding: 12px 16px; border-bottom: 1px solid #21262d; align-items: center; overflow: hidden; }
    .task:hover { background: #1c2128; }
    .task-id { font-family: monospace; color: #8b949e; font-size: 13px; }
    .task-status { font-size: 11px; padding: 2px 8px; border-radius: 12px; text-align: center; }
    .task-status.pending { background: #f0883e20; color: #f0883e; }
    .task-status.running { background: #58a6ff20; color: #58a6ff; }
    .task-status.completed { background: #3fb95020; color: #3fb950; }
    .task-status.failed { background: #f8514920; color: #f85149; }
    .action-btn.retry { background: #f0883e; }
    .action-btn.retry:hover { background: #d97706; }
    .task-info { overflow: hidden; }
    .task-type { font-size: 11px; color: #8b949e; }
    .task-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 13px; }
    .task-time { font-size: 12px; color: #8b949e; }
    .task-link a { color: #58a6ff; text-decoration: none; font-size: 12px; }

    .refresh-btn { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; }
    .refresh-btn:hover { background: #30363d; }

    .action-btn { background: #238636; border: none; color: #fff; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap; }
    .action-btn:hover { background: #2ea043; }
    .action-btn:disabled { background: #21262d; color: #8b949e; cursor: not-allowed; }
    .action-btn.secondary { background: #30363d; }
    .action-btn.secondary:hover { background: #3d444d; }
    .item-actions { display: flex; gap: 8px; align-items: center; }

    .filters { display: flex; gap: 8px; padding: 12px 16px; border-bottom: 1px solid #30363d; flex-wrap: wrap; }
    .filter-btn { background: transparent; border: 1px solid #30363d; color: #8b949e; padding: 4px 12px; border-radius: 16px; cursor: pointer; font-size: 12px; }
    .filter-btn:hover { border-color: #58a6ff; color: #c9d1d9; }
    .filter-btn.active { background: #58a6ff20; border-color: #58a6ff; color: #58a6ff; }

    .task-row { cursor: pointer; }
    .task-output {
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      background: #0d1117;
      padding: 12px;
      max-height: 400px;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-break: break-word;
      color: #8b949e;
      border-top: 1px solid #21262d;
      display: none;
    }
    .task-output.visible { display: block; }
    .task-output .chunk { color: #c9d1d9; }
    .steer-input {
      display: none;
      padding: 8px 12px;
      gap: 8px;
      border-top: 1px solid #21262d;
      background: #161b22;
    }
    .steer-input.visible { display: flex; }
    .steer-input input {
      flex: 1;
      background: #0d1117;
      border: 1px solid #30363d;
      color: #c9d1d9;
      padding: 6px 10px;
      border-radius: 4px;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 12px;
    }
    .steer-input input:focus { outline: none; border-color: #58a6ff; }
    .task-wrapper { border-bottom: 1px solid #21262d; overflow-x: hidden; }
    .task-wrapper:last-child { border-bottom: none; }
    .task { border-bottom: none; }

    /* Testing Assignment section */
    .team-selection { display: flex; flex-wrap: wrap; gap: 8px; padding: 12px 16px; border-bottom: 1px solid #30363d; }
    .team-member { display: flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 16px; background: #21262d; cursor: pointer; font-size: 12px; }
    .team-member:hover { background: #30363d; }
    .team-member.selected { background: #238636; color: #fff; }
    .sprint-header { padding: 12px 16px; background: #21262d; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
    .assign-controls { padding: 12px 16px; border-top: 1px solid #30363d; display: flex; gap: 8px; justify-content: flex-end; }
    .reviewed-meta { display: flex; gap: 8px; margin-top: 4px; }
    .reviewed-meta .badge-person { background: #30363d; color: #c9d1d9; padding: 2px 8px; border-radius: 4px; font-size: 11px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Orch Dashboard</h1>
      <div style="display: flex; gap: 12px; align-items: center;">
        <div style="display:flex;gap:8px;align-items:center;font-size:12px;color:#8b949e;">
          <span>5h</span><progress id="usage5h" class="bright" value="0" max="100" title="..." style="width:60px;height:8px;"></progress><span id="pct5h">-</span>
          <span style="margin-left:4px;">7d</span><progress id="usage7d" class="dim" value="0" max="100" title="..." style="width:60px;height:8px;"></progress><span id="pct7d">-</span>
        </div>
        <button class="refresh-btn" onclick="refreshAll()">Refresh</button>
        <div class="status">
          <div class="status-dot" id="statusDot"></div>
          <span id="statusText">Connected</span>
        </div>
      </div>
    </header>

    <div class="card" style="margin-bottom: 24px;">
      <h2>My Work Items</h2>
      <div class="filters" id="workFilters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="new">To Do</button>
        <button class="filter-btn" data-filter="active">In Progress</button>
        <button class="filter-btn" data-filter="resolved">Resolved</button>
        <button class="filter-btn" data-filter="reviewed">Reviewed</button>
        <button class="filter-btn" data-filter="resolved-by-me">Resolved by me</button>
      </div>
      <div class="card-list" id="workList">
        <div class="empty">Loading...</div>
      </div>
    </div>

    <div class="card" style="margin-bottom: 24px;">
      <h2>Testing Assignment</h2>
      <div class="sprint-header" id="sprintHeader">
        <span id="sprintName">Loading sprint...</span>
        <span id="reviewedCount">0 items</span>
      </div>
      <div class="team-selection" id="teamSelection">
        <div class="empty" style="padding: 0; width: 100%;">Loading team members...</div>
      </div>
      <div class="card-list" id="reviewedList" style="max-height: 300px;">
        <div class="empty">Loading reviewed items...</div>
      </div>
      <div class="assign-controls">
        <button class="action-btn secondary" onclick="selectAllTeam()">Select All</button>
        <button class="action-btn secondary" onclick="deselectAllTeam()">Deselect All</button>
        <button class="action-btn" onclick="generateAssignCommand()">Copy Assign Command</button>
      </div>
    </div>

    <div class="card tasks">
      <h2>Orch Tasks</h2>
      <div class="card-list" id="taskList">
        <div class="empty">No tasks yet</div>
      </div>
    </div>

    <div class="card" style="margin-top: 24px;">
      <h2 style="display:flex;justify-content:space-between;align-items:center;">
        <span>Processes</span>
        <div style="display:flex;gap:8px;">
          <button class="action-btn secondary" onclick="fetchProcesses()">Refresh</button>
          <button class="action-btn" style="background:#f0883e;" onclick="killOldProcesses()">Kill Old (2h+)</button>
          <button class="action-btn" style="background:#f85149;" onclick="killAllProcesses()">Kill All</button>
        </div>
      </h2>
      <div class="card-list" id="processList" style="max-height:300px;">
        <div class="empty">Click Refresh to load</div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = '';
    let ws;
    let allPRs = [];
    let allWorkItems = [];
    let resolvedByMeItems = [];
    let currentFilter = 'all';

    // Testing Assignment state
    let reviewedItems = [];
    let teamMembers = [];
    let selectedTeamMembers = new Set();

    function formatTime(iso) {
      if (!iso) return '-';
      const d = new Date(iso);
      const now = new Date();
      const diff = now - d;
      if (diff < 60000) return 'just now';
      if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
      if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
      return Math.floor(diff / 86400000) + 'd ago';
    }

    function stateClass(state) {
      const s = state.toLowerCase();
      if (s === 'open' || s === 'active' || s === 'in progress') return 'state-active';
      if (s === 'new') return 'state-new';
      if (s === 'closed' || s === 'resolved' || s === 'done') return 'state-resolved';
      return '';
    }

    function typeClass(type) {
      const t = type.toLowerCase();
      if (t.includes('bug')) return 'type-bug';
      if (t.includes('feature') || t.includes('story')) return 'type-feature';
      if (t.includes('task')) return 'type-task';
      return '';
    }

    // Store PR data for action handlers
    const prCache = new Map();

    function extractAdoTicket(title) {
      // Match patterns like #12345, AB#12345, ADO#12345
      const match = title.match(/(?:AB|ADO)?#(\d{4,6})/i);
      return match ? match[1] : null;
    }

    function renderPR(pr) {
      const key = `${pr.repo}#${pr.number}`;
      prCache.set(key, pr);

      const adoTicket = extractAdoTicket(pr.title);

      // Show "Fix Comments" button for PRs where user is author
      const fixCommentsBtn = pr.role === 'author'
        ? `<button class="action-btn" style="background:#a371f7;" onclick="fixPRCommentsByKey('${key}')">Fix Comments</button>`
        : '';

      return `
        <div class="item">
          <div class="item-info">
            <div class="item-title">${escapeHtml(pr.title)}</div>
            <div class="item-meta">
              <span class="badge" style="background:#a371f720;color:#a371f7;">PR</span>
              <span>${pr.repo}#${pr.number}</span>
              <span class="badge role-${pr.role}">${pr.role}</span>
              <span class="badge state ${stateClass(pr.state)}">${pr.draft ? 'draft' : pr.state}</span>
              ${adoTicket ? `<span class="badge" style="background:#58a6ff20;color:#58a6ff;">ADO#${adoTicket}</span>` : ''}
              <span>${formatTime(pr.updatedAt)}</span>
            </div>
          </div>
          <div class="item-actions">
            ${fixCommentsBtn}
            <button class="action-btn" onclick="reviewPRByKey('${key}')">Review</button>
            <a href="${escapeHtml(pr.url)}" target="_blank" class="action-btn secondary">View →</a>
          </div>
        </div>
      `;
    }

    // Store work item data for action handlers
    const workItemCache = new Map();

    function renderWorkItem(wi) {
      // Cache the full work item data
      workItemCache.set(wi.id, wi);

      const isResolved = wi.state.toLowerCase() === 'resolved' || wi.state.toLowerCase() === 'reviewed';
      const hasPr = wi.githubPrUrl || (wi.resolution && wi.resolution.includes('github.com'));

      let actionBtn;
      if (isResolved && hasPr) {
        actionBtn = `<button class="action-btn" onclick="reviewResolutionById(${wi.id})">Review</button>`;
      } else {
        const actionLabel = wi.type.toLowerCase().includes('bug') ? 'Fix' : 'Implement';
        actionBtn = `<button class="action-btn" onclick="analyzeWorkItemById(${wi.id})">${actionLabel}</button>`;
      }

      return `
        <div class="item">
          <div class="item-info">
            <div class="item-title">${escapeHtml(wi.title)}</div>
            <div class="item-meta">
              <span>${wi.project} #${wi.id}</span>
              <span class="badge type ${typeClass(wi.type)}">${wi.type}</span>
              <span class="badge state ${stateClass(wi.state)}">${wi.state}</span>
              ${hasPr ? '<span class="badge" style="background:#3fb95020;color:#3fb950;">PR</span>' : ''}
              <span>${formatTime(wi.updatedAt)}</span>
            </div>
          </div>
          <div class="item-actions">
            ${actionBtn}
            ${wi.githubPrUrl ? `<a href="${escapeHtml(wi.githubPrUrl)}" target="_blank" class="action-btn secondary">PR</a>` : ''}
            <a href="${escapeHtml(wi.url)}" target="_blank" class="action-btn secondary">View →</a>
          </div>
        </div>
      `;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function renderTask(task) {
      const isRunning = task.status === 'running';
      const isFailed = task.status === 'failed';
      const canDelete = task.status !== 'running';
      const hasOutput = task.streamingOutput || task.result || task.error;
      const retryInfo = task.context?.retryCount ? ` (retry #${task.context.retryCount})` : '';

      let actionBtn = `<button class="action-btn secondary" onclick="event.stopPropagation(); openTerminal(${task.id})">Terminal</button>`;
      if (isRunning) {
        actionBtn += `
          <button class="action-btn" style="background:#3fb950;" onclick="event.stopPropagation(); completeTask(${task.id})">Done</button>
          <button class="action-btn" style="background:#f85149;" onclick="event.stopPropagation(); stopTask(${task.id})">Stop</button>`;
      } else if (isFailed) {
        actionBtn += `<button class="action-btn retry" onclick="event.stopPropagation(); retryTask(${task.id})">Retry</button>`;
        actionBtn += `<button class="action-btn secondary" onclick="event.stopPropagation(); deleteTask(${task.id})">Delete</button>`;
      } else if (canDelete) {
        actionBtn += `<button class="action-btn secondary" onclick="event.stopPropagation(); deleteTask(${task.id})">Delete</button>`;
      }

      return `
        <div class="task-wrapper" data-task-id="${task.id}">
          <div class="task task-row" onclick="toggleTaskOutput(${task.id})">
            <div class="task-id">#${task.id}</div>
            <div class="task-status ${task.status}">${task.status}</div>
            <div class="task-info">
              <div class="task-type">${task.type}${retryInfo}</div>
              <div class="task-title">${escapeHtml(task.context?.title || task.repo)}</div>
            </div>
            <div class="task-time">${formatTime(task.createdAt)}</div>
            <div class="task-actions" style="display:flex;gap:8px;align-items:center;">
              ${actionBtn}
              ${task.context?.url ? `<a href="${escapeHtml(task.context.url)}" target="_blank" class="action-btn secondary" onclick="event.stopPropagation()">View</a>` : ''}
            </div>
          </div>
          <div class="task-output" id="output-${task.id}">${hasOutput ? `<span class="chunk">${escapeHtml(task.streamingOutput || task.result || task.error || '')}</span>` : '<span style="color:#8b949e">No output yet...</span>'}</div>
          ${isRunning ? `
          <div class="steer-input" id="steer-${task.id}">
            <input type="text" placeholder="Send input to Claude..." onkeydown="handleSteerKey(event, ${task.id})">
            <button class="action-btn" onclick="sendSteer(${task.id})">Send</button>
          </div>
          ` : ''}
        </div>
      `;
    }

    async function fetchPRs() {
      try {
        const res = await fetch(API_BASE + '/api/my/prs');
        allPRs = await res.json();
        renderUnifiedList();
      } catch (err) {
        console.error('Failed to fetch PRs:', err);
        allPRs = [];
        renderUnifiedList();
      }
    }

    async function fetchWorkItems() {
      try {
        const res = await fetch(API_BASE + '/api/my/workitems');
        allWorkItems = await res.json();
        renderUnifiedList();
      } catch (err) {
        console.error('Failed to fetch work items:', err);
        allWorkItems = [];
        renderUnifiedList();
      }
    }

    async function fetchResolvedByMe() {
      try {
        const res = await fetch(API_BASE + '/api/my/resolved-workitems');
        resolvedByMeItems = await res.json();
        // Only re-render if that filter is active
        if (currentFilter === 'resolved-by-me') {
          renderUnifiedList();
        }
      } catch (err) {
        console.error('Failed to fetch resolved-by-me items:', err);
        resolvedByMeItems = [];
      }
    }

    function renderUnifiedList() {
      const list = document.getElementById('workList');

      // Filter work items
      let filteredWorkItems;
      if (currentFilter === 'resolved-by-me') {
        filteredWorkItems = resolvedByMeItems;
      } else {
        filteredWorkItems = allWorkItems.filter(wi => {
          const state = wi.state.toLowerCase();
          if (state === 'completed' || state === 'done' || state === 'closed') return false;
          if (currentFilter === 'all') return true;
          if (currentFilter === 'new') return state === 'new' || state === 'to do';
          if (currentFilter === 'active') return state === 'active' || state === 'in progress';
          if (currentFilter === 'resolved') return state === 'resolved';
          if (currentFilter === 'reviewed') return state === 'reviewed';
          return true;
        });
      }

      // PRs only show if filter is not resolved-by-me
      const showPRs = currentFilter !== 'resolved-by-me';
      const prsToShow = showPRs ? allPRs : [];

      // Sort work items by updated date
      filteredWorkItems.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

      if (prsToShow.length === 0 && filteredWorkItems.length === 0) {
        list.innerHTML = '<div class="empty">No items match filter</div>';
        return;
      }

      // PRs at top, then work items
      const prHtml = prsToShow.map(renderPR).join('');
      const wiHtml = filteredWorkItems.map(renderWorkItem).join('');
      list.innerHTML = prHtml + wiHtml;
    }

    function setFilter(filter) {
      currentFilter = filter;
      document.querySelectorAll('#workFilters .filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });
      renderUnifiedList();
    }

    async function fetchTasks() {
      try {
        const res = await fetch(API_BASE + '/api/tasks');
        const tasks = await res.json();
        const list = document.getElementById('taskList');
        if (tasks.length === 0) {
          list.innerHTML = '<div class="empty">No tasks yet</div>';
          return;
        }
        list.innerHTML = tasks.map(renderTask).join('');
      } catch (err) {
        console.error('Failed to fetch tasks:', err);
      }
    }

    async function fetchProcesses() {
      const list = document.getElementById('processList');
      list.innerHTML = '<div class="empty">Loading...</div>';
      try {
        const res = await fetch(API_BASE + '/api/processes');
        const procs = await res.json();
        if (procs.length === 0) {
          list.innerHTML = '<div class="empty">No Orch processes running</div>';
          return;
        }
        // Sort by start time (oldest first)
        procs.sort((a, b) => new Date(a.startTime || 0) - new Date(b.startTime || 0));
        list.innerHTML = procs.map(p => {
          const age = p.startTime ? formatTime(p.startTime) : 'unknown';
          const taskInfo = p.taskId ? `Task #${p.taskId} (${p.taskType})` : 'Unknown task';
          const repoInfo = p.repo ? escapeHtml(p.repo) : '';
          return `
            <div class="item" style="grid-template-columns: 1fr auto;">
              <div class="item-info">
                <div class="item-title">${taskInfo} - PID ${p.pid}</div>
                <div class="item-meta">
                  ${repoInfo ? `<span>${repoInfo}</span>` : ''}
                  <span>Started ${age}</span>
                </div>
              </div>
              <div class="item-actions">
                <button class="action-btn" style="background:#f85149;" onclick="killProcess(${p.pid})">Kill</button>
              </div>
            </div>
          `;
        }).join('');
      } catch (err) {
        list.innerHTML = '<div class="empty">Error loading processes</div>';
      }
    }

    async function killProcess(pid) {
      if (!confirm(`Kill process ${pid}?`)) return;
      try {
        await fetch(`${API_BASE}/api/processes/${pid}/kill`, { method: 'POST' });
        fetchProcesses();
      } catch (err) {
        alert('Failed to kill process');
      }
    }

    async function killOldProcesses() {
      if (!confirm('Kill Orch task processes older than 2 hours?')) return;
      try {
        await fetch(`${API_BASE}/api/processes/kill-old`, { method: 'POST' });
        fetchProcesses();
      } catch (err) {
        alert('Failed to kill old processes');
      }
    }

    async function killAllProcesses() {
      if (!confirm('Kill all Orch task processes?')) return;
      try {
        await fetch(`${API_BASE}/api/processes/kill-all`, { method: 'POST' });
        fetchProcesses();
      } catch (err) {
        alert('Failed to kill processes');
      }
    }

    async function fetchReviewedItems() {
      try {
        const res = await fetch(API_BASE + '/api/sprint/reviewed-items');
        const data = await res.json();
        reviewedItems = data.items || [];
        document.getElementById('sprintName').textContent = data.sprintName || 'No sprint';
        document.getElementById('reviewedCount').textContent = `${reviewedItems.length} items`;
        renderReviewedItems();
      } catch (err) {
        console.error('Failed to fetch reviewed items:', err);
        document.getElementById('reviewedList').innerHTML = '<div class="empty">Failed to load</div>';
      }
    }

    async function fetchTeamMembers() {
      try {
        const res = await fetch(API_BASE + '/api/team/members');
        teamMembers = await res.json();
        renderTeamSelection();
      } catch (err) {
        console.error('Failed to fetch team members:', err);
        document.getElementById('teamSelection').innerHTML = '<div class="empty" style="padding:0;width:100%;">Failed to load team</div>';
      }
    }

    function renderTeamSelection() {
      const container = document.getElementById('teamSelection');
      if (teamMembers.length === 0) {
        container.innerHTML = '<div class="empty" style="padding:0;width:100%;">No team members found. Set ADO_PROJECT and ADO_TEAM env vars.</div>';
        return;
      }
      container.innerHTML = teamMembers.map(m => {
        const selected = selectedTeamMembers.has(m.email);
        return `
          <span class="team-member ${selected ? 'selected' : ''}" onclick="toggleTeamMember('${escapeHtml(m.email)}')">
            ${escapeHtml(m.displayName)}
          </span>
        `;
      }).join('');
    }

    function toggleTeamMember(email) {
      if (selectedTeamMembers.has(email)) {
        selectedTeamMembers.delete(email);
      } else {
        selectedTeamMembers.add(email);
      }
      renderTeamSelection();
    }

    function selectAllTeam() {
      teamMembers.forEach(m => selectedTeamMembers.add(m.email));
      renderTeamSelection();
    }

    function deselectAllTeam() {
      selectedTeamMembers.clear();
      renderTeamSelection();
    }

    function renderReviewedItems() {
      const list = document.getElementById('reviewedList');
      if (reviewedItems.length === 0) {
        list.innerHTML = '<div class="empty">No reviewed items in current sprint</div>';
        return;
      }
      list.innerHTML = reviewedItems.map(wi => `
        <div class="item">
          <div class="item-info">
            <div class="item-title">${escapeHtml(wi.title)}</div>
            <div class="item-meta">
              <span>#${wi.id}</span>
              <span class="badge type ${typeClass(wi.type)}">${wi.type}</span>
            </div>
            <div class="reviewed-meta">
              <span class="badge-person">Resolved: ${escapeHtml(wi.resolvedBy || 'N/A')}</span>
              <span class="badge-person">Reviewed: ${escapeHtml(wi.reviewedBy || 'N/A')}</span>
            </div>
          </div>
          <div class="item-actions">
            <a href="${escapeHtml(wi.url)}" target="_blank" class="action-btn secondary">View →</a>
          </div>
        </div>
      `).join('');
    }

    function generateAssignCommand() {
      if (selectedTeamMembers.size === 0) {
        alert('Select at least one team member');
        return;
      }
      if (reviewedItems.length === 0) {
        alert('No reviewed items to assign');
        return;
      }
      const users = Array.from(selectedTeamMembers).join(',');
      const cmd = `/assign-testing --users "${users}"`;
      navigator.clipboard.writeText(cmd).then(() => {
        alert(`Copied to clipboard:\n${cmd}\n\nPaste in Claude Code to run the skill.`);
      }).catch(() => {
        prompt('Copy this command:', cmd);
      });
    }

    function refreshAll() {
      fetchPRs();
      fetchWorkItems();
      fetchResolvedByMe();
      fetchTasks();
      fetchClaudeUsage();
      fetchReviewedItems();
      fetchTeamMembers();
    }

    function formatResetTime(iso) {
      if (!iso) return '';
      const ms = new Date(iso) - Date.now();
      if (ms <= 0) return 'resets soon';
      const h = Math.floor(ms / 3600000);
      const m = Math.floor((ms % 3600000) / 60000);
      return h > 0 ? `resets in ${h}h ${m}m` : `resets in ${m}m`;
    }

    async function fetchClaudeUsage() {
      const p5h = document.getElementById('usage5h');
      const p7d = document.getElementById('usage7d');
      const pct5h = document.getElementById('pct5h');
      const pct7d = document.getElementById('pct7d');
      try {
        const res = await fetch(API_BASE + '/api/claude/usage');
        if (!res.ok) return;
        const u = await res.json();
        const v5h = Math.round(u.five_hour?.utilization ?? 0);
        const v7d = Math.round(u.seven_day?.utilization ?? 0);
        p5h.value = v5h; p5h.title = formatResetTime(u.five_hour?.resets_at);
        p7d.value = v7d; p7d.title = formatResetTime(u.seven_day?.resets_at);
        pct5h.textContent = `${v5h}%`;
        pct7d.textContent = `${v7d}%`;
      } catch {}
    }

    async function reviewPRByKey(key) {
      const pr = prCache.get(key);
      if (!pr) { alert('PR not found'); return; }

      const data = {
        repo: pr.repo,
        prNumber: pr.number,
        source: 'github',
        title: pr.title,
        url: pr.url,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/review-pr', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    async function fixPRCommentsByKey(key) {
      const pr = prCache.get(key);
      if (!pr) { alert('PR not found'); return; }

      const data = {
        repo: pr.repo,
        prNumber: pr.number,
        source: 'github',
        title: pr.title,
        url: pr.url,
        branch: pr.branch,
        baseBranch: pr.baseBranch,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/fix-pr-comments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    async function analyzeWorkItemById(id) {
      const wi = workItemCache.get(id);
      if (!wi) { alert('Work item not found'); return; }

      const data = {
        id: wi.id,
        title: wi.title,
        project: wi.project,
        url: wi.url,
        type: wi.type,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/analyze-workitem', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    async function reviewResolutionById(id) {
      const wi = workItemCache.get(id);
      if (!wi) { alert('Work item not found'); return; }

      const data = {
        id: wi.id,
        title: wi.title,
        project: wi.project,
        url: wi.url,
        resolution: wi.resolution,
        githubPrUrl: wi.githubPrUrl,
        testNotes: wi.testNotes,
        body: wi.body,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/review-resolution', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    // Track expanded tasks
    const expandedTasks = new Set();

    function toggleTaskOutput(taskId) {
      const outputEl = document.getElementById(`output-${taskId}`);
      const steerEl = document.getElementById(`steer-${taskId}`);
      if (!outputEl) return;

      const isExpanded = expandedTasks.has(taskId);
      if (isExpanded) {
        expandedTasks.delete(taskId);
        outputEl.classList.remove('visible');
        if (steerEl) steerEl.classList.remove('visible');
      } else {
        expandedTasks.add(taskId);
        outputEl.classList.add('visible');
        if (steerEl) steerEl.classList.add('visible');
        // Scroll to bottom
        outputEl.scrollTop = outputEl.scrollHeight;
      }
    }

    function appendOutput(taskId, chunk) {
      const outputEl = document.getElementById(`output-${taskId}`);
      if (!outputEl) return;

      // Get or create the chunk span
      let chunkEl = outputEl.querySelector('.chunk');
      if (!chunkEl) {
        outputEl.innerHTML = '<span class="chunk"></span>';
        chunkEl = outputEl.querySelector('.chunk');
      }
      chunkEl.textContent += chunk;

      // Auto-scroll if expanded
      if (expandedTasks.has(taskId)) {
        outputEl.scrollTop = outputEl.scrollHeight;
      }
    }

    function handleSteerKey(event, taskId) {
      if (event.key === 'Enter') {
        event.preventDefault();
        sendSteer(taskId);
      }
    }

    function sendSteer(taskId) {
      const steerEl = document.getElementById(`steer-${taskId}`);
      const input = steerEl?.querySelector('input');
      if (!input?.value || !ws) return;

      ws.send(JSON.stringify({ type: 'steer', taskId, input: input.value }));
      appendOutput(taskId, `\n> ${input.value}\n`);
      input.value = '';
    }

    async function stopTask(taskId) {
      if (!confirm(`Stop task #${taskId}?`)) return;
      try {
        const res = await fetch(`${API_BASE}/api/tasks/${taskId}/stop`, { method: 'POST' });
        const result = await res.json();
        if (!res.ok) alert(`Error: ${result.error}`);
      } catch (err) {
        alert('Failed to stop task: ' + err.message);
      }
    }

    async function deleteTask(taskId) {
      if (!confirm(`Delete task #${taskId}?`)) return;
      try {
        const res = await fetch(`${API_BASE}/api/tasks/${taskId}`, { method: 'DELETE' });
        const result = await res.json();
        if (!res.ok) alert(`Error: ${result.error}`);
      } catch (err) {
        alert('Failed to delete task: ' + err.message);
      }
    }

    async function retryTask(taskId) {
      try {
        const res = await fetch(`${API_BASE}/api/tasks/${taskId}/retry`, { method: 'POST' });
        if (!res.ok) {
          const result = await res.json();
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to retry task: ' + err.message);
      }
    }

    async function completeTask(taskId) {
      try {
        const res = await fetch(`${API_BASE}/api/tasks/${taskId}/complete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ result: 'Completed via terminal' })
        });
        const result = await res.json();
        if (!res.ok) alert(`Error: ${result.error}`);
      } catch (err) {
        alert('Failed to complete task: ' + err.message);
      }
    }

    async function openTerminal(taskId) {
      try {
        const res = await fetch(`${API_BASE}/api/tasks/${taskId}/terminal`, { method: 'POST' });
        const result = await res.json();
        if (!res.ok) alert(`Error: ${result.error}`);
      } catch (err) {
        alert('Failed to open terminal: ' + err.message);
      }
    }

    function connectWebSocket() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws`);

      ws.onopen = () => {
        document.getElementById('statusDot').classList.remove('disconnected');
        document.getElementById('statusText').textContent = 'Connected';
      };

      ws.onclose = () => {
        document.getElementById('statusDot').classList.add('disconnected');
        document.getElementById('statusText').textContent = 'Disconnected';
        setTimeout(connectWebSocket, 3000);
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'tasks') {
          const list = document.getElementById('taskList');
          if (data.tasks.length === 0) {
            list.innerHTML = '<div class="empty">No tasks yet</div>';
          } else {
            list.innerHTML = data.tasks.map(renderTask).join('');
            // Restore expanded state
            expandedTasks.forEach(taskId => {
              const outputEl = document.getElementById(`output-${taskId}`);
              const steerEl = document.getElementById(`steer-${taskId}`);
              if (outputEl) {
                outputEl.classList.add('visible');
                outputEl.scrollTop = outputEl.scrollHeight;
              }
              if (steerEl) steerEl.classList.add('visible');
            });
          }
        } else if (data.type === 'output') {
          appendOutput(data.taskId, data.chunk);
        } else if (data.type === 'steerResult' && !data.success) {
          console.warn(`Failed to steer task ${data.taskId}`);
        }
      };
    }

    // Filter button handlers
    document.querySelectorAll('#workFilters .filter-btn').forEach(btn => {
      btn.addEventListener('click', () => setFilter(btn.dataset.filter));
    });

    // Initial load
    fetchPRs();
    fetchWorkItems();
    fetchResolvedByMe();
    fetchTasks();
    fetchClaudeUsage();
    fetchReviewedItems();
    fetchTeamMembers();
    connectWebSocket();

    // Refresh every 2 minutes
    setInterval(refreshAll, 120000);
  </script>
</body>
</html>
