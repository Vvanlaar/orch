<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orch Dashboard</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0d1117; color: #c9d1d9; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; }
    h1 { font-size: 24px; font-weight: 600; }
    h2 { font-size: 16px; font-weight: 600; padding: 16px; border-bottom: 1px solid #30363d; }
    .status { display: flex; align-items: center; gap: 8px; font-size: 14px; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #3fb950; }
    .status-dot.disconnected { background: #f85149; }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 24px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }

    .card { background: #161b22; border: 1px solid #30363d; border-radius: 6px; overflow: hidden; }
    .card-list { max-height: 400px; overflow-y: auto; }

    .item { display: grid; grid-template-columns: 1fr auto; gap: 12px; padding: 12px 16px; border-bottom: 1px solid #21262d; align-items: center; }
    .item:hover { background: #1c2128; }
    .item-info { overflow: hidden; }
    .item-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 14px; }
    .item-meta { font-size: 12px; color: #8b949e; margin-top: 4px; display: flex; gap: 12px; flex-wrap: wrap; }
    .item-link a { color: #58a6ff; text-decoration: none; font-size: 13px; white-space: nowrap; }
    .item-link a:hover { text-decoration: underline; }

    .badge { font-size: 11px; padding: 2px 8px; border-radius: 12px; }
    .badge.state { background: #30363d; color: #8b949e; }
    .badge.state-active, .badge.state-open { background: #3fb95020; color: #3fb950; }
    .badge.state-new { background: #58a6ff20; color: #58a6ff; }
    .badge.state-resolved, .badge.state-closed { background: #8b949e20; color: #8b949e; }
    .badge.role-author { background: #a371f720; color: #a371f7; }
    .badge.role-reviewer { background: #f0883e20; color: #f0883e; }
    .badge.type { background: #21262d; color: #8b949e; }
    .badge.type-bug { background: #f8514920; color: #f85149; }
    .badge.type-feature, .badge.type-story { background: #3fb95020; color: #3fb950; }
    .badge.type-task { background: #58a6ff20; color: #58a6ff; }

    .empty { padding: 48px; text-align: center; color: #8b949e; }

    .tasks { margin-bottom: 24px; }
    .task { display: grid; grid-template-columns: 60px 90px 1fr 100px 100px; gap: 12px; padding: 12px 16px; border-bottom: 1px solid #21262d; align-items: center; }
    .task:hover { background: #1c2128; }
    .task-id { font-family: monospace; color: #8b949e; font-size: 13px; }
    .task-status { font-size: 11px; padding: 2px 8px; border-radius: 12px; text-align: center; }
    .task-status.pending { background: #f0883e20; color: #f0883e; }
    .task-status.running { background: #58a6ff20; color: #58a6ff; }
    .task-status.completed { background: #3fb95020; color: #3fb950; }
    .task-status.failed { background: #f8514920; color: #f85149; }
    .task-info { overflow: hidden; }
    .task-type { font-size: 11px; color: #8b949e; }
    .task-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 13px; }
    .task-time { font-size: 12px; color: #8b949e; }
    .task-link a { color: #58a6ff; text-decoration: none; font-size: 12px; }

    .refresh-btn { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; }
    .refresh-btn:hover { background: #30363d; }

    .action-btn { background: #238636; border: none; color: #fff; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap; }
    .action-btn:hover { background: #2ea043; }
    .action-btn:disabled { background: #21262d; color: #8b949e; cursor: not-allowed; }
    .action-btn.secondary { background: #30363d; }
    .action-btn.secondary:hover { background: #3d444d; }
    .item-actions { display: flex; gap: 8px; align-items: center; }

    .filters { display: flex; gap: 8px; padding: 12px 16px; border-bottom: 1px solid #30363d; flex-wrap: wrap; }
    .filter-btn { background: transparent; border: 1px solid #30363d; color: #8b949e; padding: 4px 12px; border-radius: 16px; cursor: pointer; font-size: 12px; }
    .filter-btn:hover { border-color: #58a6ff; color: #c9d1d9; }
    .filter-btn.active { background: #58a6ff20; border-color: #58a6ff; color: #58a6ff; }

    .task-row { cursor: pointer; }
    .task-output {
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      background: #0d1117;
      padding: 12px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      color: #8b949e;
      border-top: 1px solid #21262d;
      display: none;
    }
    .task-output.visible { display: block; }
    .task-output .chunk { color: #c9d1d9; }
    .steer-input {
      display: none;
      padding: 8px 12px;
      gap: 8px;
      border-top: 1px solid #21262d;
      background: #161b22;
    }
    .steer-input.visible { display: flex; }
    .steer-input input {
      flex: 1;
      background: #0d1117;
      border: 1px solid #30363d;
      color: #c9d1d9;
      padding: 6px 10px;
      border-radius: 4px;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 12px;
    }
    .steer-input input:focus { outline: none; border-color: #58a6ff; }
    .task-wrapper { border-bottom: 1px solid #21262d; }
    .task-wrapper:last-child { border-bottom: none; }
    .task { border-bottom: none; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Orch Dashboard</h1>
      <div style="display: flex; gap: 12px; align-items: center;">
        <button class="refresh-btn" onclick="refreshAll()">Refresh</button>
        <div class="status">
          <div class="status-dot" id="statusDot"></div>
          <span id="statusText">Connected</span>
        </div>
      </div>
    </header>

    <div class="card" style="margin-bottom: 24px;">
      <h2>My Work Items</h2>
      <div class="filters" id="workFilters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="new">To Do</button>
        <button class="filter-btn" data-filter="active">In Progress</button>
        <button class="filter-btn" data-filter="resolved">Resolved</button>
        <button class="filter-btn" data-filter="reviewed">Reviewed</button>
        <button class="filter-btn" data-filter="resolved-by-me">Resolved by me</button>
      </div>
      <div class="card-list" id="workList">
        <div class="empty">Loading...</div>
      </div>
    </div>

    <div class="card tasks">
      <h2>Orch Tasks</h2>
      <div class="card-list" id="taskList">
        <div class="empty">No tasks yet</div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = '';
    let ws;
    let allPRs = [];
    let allWorkItems = [];
    let resolvedByMeItems = [];
    let currentFilter = 'all';

    function formatTime(iso) {
      if (!iso) return '-';
      const d = new Date(iso);
      const now = new Date();
      const diff = now - d;
      if (diff < 60000) return 'just now';
      if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
      if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
      return Math.floor(diff / 86400000) + 'd ago';
    }

    function stateClass(state) {
      const s = state.toLowerCase();
      if (s === 'open' || s === 'active' || s === 'in progress') return 'state-active';
      if (s === 'new') return 'state-new';
      if (s === 'closed' || s === 'resolved' || s === 'done') return 'state-resolved';
      return '';
    }

    function typeClass(type) {
      const t = type.toLowerCase();
      if (t.includes('bug')) return 'type-bug';
      if (t.includes('feature') || t.includes('story')) return 'type-feature';
      if (t.includes('task')) return 'type-task';
      return '';
    }

    // Store PR data for action handlers
    const prCache = new Map();

    function extractAdoTicket(title) {
      // Match patterns like #12345, AB#12345, ADO#12345
      const match = title.match(/(?:AB|ADO)?#(\d{4,6})/i);
      return match ? match[1] : null;
    }

    function renderPR(pr) {
      const key = `${pr.repo}#${pr.number}`;
      prCache.set(key, pr);

      const adoTicket = extractAdoTicket(pr.title);

      // Show "Fix Comments" button for PRs where user is author
      const fixCommentsBtn = pr.role === 'author'
        ? `<button class="action-btn" style="background:#a371f7;" onclick="fixPRCommentsByKey('${key}')">Fix Comments</button>`
        : '';

      return `
        <div class="item">
          <div class="item-info">
            <div class="item-title">${escapeHtml(pr.title)}</div>
            <div class="item-meta">
              <span class="badge" style="background:#a371f720;color:#a371f7;">PR</span>
              <span>${pr.repo}#${pr.number}</span>
              <span class="badge role-${pr.role}">${pr.role}</span>
              <span class="badge state ${stateClass(pr.state)}">${pr.draft ? 'draft' : pr.state}</span>
              ${adoTicket ? `<span class="badge" style="background:#58a6ff20;color:#58a6ff;">ADO#${adoTicket}</span>` : ''}
              <span>${formatTime(pr.updatedAt)}</span>
            </div>
          </div>
          <div class="item-actions">
            ${fixCommentsBtn}
            <button class="action-btn" onclick="reviewPRByKey('${key}')">Review</button>
            <a href="${escapeHtml(pr.url)}" target="_blank" class="action-btn secondary">View →</a>
          </div>
        </div>
      `;
    }

    // Store work item data for action handlers
    const workItemCache = new Map();

    function renderWorkItem(wi) {
      // Cache the full work item data
      workItemCache.set(wi.id, wi);

      const isResolved = wi.state.toLowerCase() === 'resolved' || wi.state.toLowerCase() === 'reviewed';
      const hasPr = wi.githubPrUrl || (wi.resolution && wi.resolution.includes('github.com'));

      let actionBtn;
      if (isResolved && hasPr) {
        actionBtn = `<button class="action-btn" onclick="reviewResolutionById(${wi.id})">Review</button>`;
      } else {
        const actionLabel = wi.type.toLowerCase().includes('bug') ? 'Fix' : 'Implement';
        actionBtn = `<button class="action-btn" onclick="analyzeWorkItemById(${wi.id})">${actionLabel}</button>`;
      }

      return `
        <div class="item">
          <div class="item-info">
            <div class="item-title">${escapeHtml(wi.title)}</div>
            <div class="item-meta">
              <span>${wi.project} #${wi.id}</span>
              <span class="badge type ${typeClass(wi.type)}">${wi.type}</span>
              <span class="badge state ${stateClass(wi.state)}">${wi.state}</span>
              ${hasPr ? '<span class="badge" style="background:#3fb95020;color:#3fb950;">PR</span>' : ''}
              <span>${formatTime(wi.updatedAt)}</span>
            </div>
          </div>
          <div class="item-actions">
            ${actionBtn}
            ${wi.githubPrUrl ? `<a href="${escapeHtml(wi.githubPrUrl)}" target="_blank" class="action-btn secondary">PR</a>` : ''}
            <a href="${escapeHtml(wi.url)}" target="_blank" class="action-btn secondary">View →</a>
          </div>
        </div>
      `;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function renderTask(task) {
      const isRunning = task.status === 'running';
      const hasOutput = task.streamingOutput || task.result || task.error;
      return `
        <div class="task-wrapper" data-task-id="${task.id}">
          <div class="task task-row" onclick="toggleTaskOutput(${task.id})">
            <div class="task-id">#${task.id}</div>
            <div class="task-status ${task.status}">${task.status}</div>
            <div class="task-info">
              <div class="task-type">${task.type}</div>
              <div class="task-title">${escapeHtml(task.context?.title || task.repo)}</div>
            </div>
            <div class="task-time">${formatTime(task.createdAt)}</div>
            <div class="task-link">
              ${task.context?.url ? `<a href="${escapeHtml(task.context.url)}" target="_blank" onclick="event.stopPropagation()">View</a>` : ''}
            </div>
          </div>
          <div class="task-output" id="output-${task.id}">${hasOutput ? `<span class="chunk">${escapeHtml(task.streamingOutput || task.result || task.error || '')}</span>` : '<span style="color:#8b949e">No output yet...</span>'}</div>
          ${isRunning ? `
          <div class="steer-input" id="steer-${task.id}">
            <input type="text" placeholder="Send input to Claude..." onkeydown="handleSteerKey(event, ${task.id})">
            <button class="action-btn" onclick="sendSteer(${task.id})">Send</button>
          </div>
          ` : ''}
        </div>
      `;
    }

    async function fetchPRs() {
      try {
        const res = await fetch(API_BASE + '/api/my/prs');
        allPRs = await res.json();
        renderUnifiedList();
      } catch (err) {
        console.error('Failed to fetch PRs:', err);
        allPRs = [];
        renderUnifiedList();
      }
    }

    async function fetchWorkItems() {
      try {
        const res = await fetch(API_BASE + '/api/my/workitems');
        allWorkItems = await res.json();
        renderUnifiedList();
      } catch (err) {
        console.error('Failed to fetch work items:', err);
        allWorkItems = [];
        renderUnifiedList();
      }
    }

    async function fetchResolvedByMe() {
      try {
        const res = await fetch(API_BASE + '/api/my/resolved-workitems');
        resolvedByMeItems = await res.json();
        // Only re-render if that filter is active
        if (currentFilter === 'resolved-by-me') {
          renderUnifiedList();
        }
      } catch (err) {
        console.error('Failed to fetch resolved-by-me items:', err);
        resolvedByMeItems = [];
      }
    }

    function renderUnifiedList() {
      const list = document.getElementById('workList');

      // Filter work items
      let filteredWorkItems;
      if (currentFilter === 'resolved-by-me') {
        filteredWorkItems = resolvedByMeItems;
      } else {
        filteredWorkItems = allWorkItems.filter(wi => {
          const state = wi.state.toLowerCase();
          if (state === 'completed' || state === 'done' || state === 'closed') return false;
          if (currentFilter === 'all') return true;
          if (currentFilter === 'new') return state === 'new' || state === 'to do';
          if (currentFilter === 'active') return state === 'active' || state === 'in progress';
          if (currentFilter === 'resolved') return state === 'resolved';
          if (currentFilter === 'reviewed') return state === 'reviewed';
          return true;
        });
      }

      // PRs only show if filter is not resolved-by-me
      const showPRs = currentFilter !== 'resolved-by-me';
      const prsToShow = showPRs ? allPRs : [];

      // Sort work items by updated date
      filteredWorkItems.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

      if (prsToShow.length === 0 && filteredWorkItems.length === 0) {
        list.innerHTML = '<div class="empty">No items match filter</div>';
        return;
      }

      // PRs at top, then work items
      const prHtml = prsToShow.map(renderPR).join('');
      const wiHtml = filteredWorkItems.map(renderWorkItem).join('');
      list.innerHTML = prHtml + wiHtml;
    }

    function setFilter(filter) {
      currentFilter = filter;
      document.querySelectorAll('#workFilters .filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });
      renderUnifiedList();
    }

    async function fetchTasks() {
      try {
        const res = await fetch(API_BASE + '/api/tasks');
        const tasks = await res.json();
        const list = document.getElementById('taskList');
        if (tasks.length === 0) {
          list.innerHTML = '<div class="empty">No tasks yet</div>';
          return;
        }
        list.innerHTML = tasks.map(renderTask).join('');
      } catch (err) {
        console.error('Failed to fetch tasks:', err);
      }
    }

    function refreshAll() {
      fetchPRs();
      fetchWorkItems();
      fetchResolvedByMe();
      fetchTasks();
    }

    async function reviewPRByKey(key) {
      const pr = prCache.get(key);
      if (!pr) { alert('PR not found'); return; }

      const data = {
        repo: pr.repo,
        prNumber: pr.number,
        source: 'github',
        title: pr.title,
        url: pr.url,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/review-pr', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    async function fixPRCommentsByKey(key) {
      const pr = prCache.get(key);
      if (!pr) { alert('PR not found'); return; }

      const data = {
        repo: pr.repo,
        prNumber: pr.number,
        source: 'github',
        title: pr.title,
        url: pr.url,
        branch: pr.branch,
        baseBranch: pr.baseBranch,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/fix-pr-comments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    async function analyzeWorkItemById(id) {
      const wi = workItemCache.get(id);
      if (!wi) { alert('Work item not found'); return; }

      const data = {
        id: wi.id,
        title: wi.title,
        project: wi.project,
        url: wi.url,
        type: wi.type,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/analyze-workitem', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    async function reviewResolutionById(id) {
      const wi = workItemCache.get(id);
      if (!wi) { alert('Work item not found'); return; }

      const data = {
        id: wi.id,
        title: wi.title,
        project: wi.project,
        url: wi.url,
        resolution: wi.resolution,
        githubPrUrl: wi.githubPrUrl,
        testNotes: wi.testNotes,
        body: wi.body,
      };

      try {
        const res = await fetch(API_BASE + '/api/actions/review-resolution', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await res.json();
        if (res.ok) {
          alert(`Task #${result.taskId} created: ${result.message}`);
        } else {
          alert(`Error: ${result.error}`);
        }
      } catch (err) {
        alert('Failed to create task: ' + err.message);
      }
    }

    // Track expanded tasks
    const expandedTasks = new Set();

    function toggleTaskOutput(taskId) {
      const outputEl = document.getElementById(`output-${taskId}`);
      const steerEl = document.getElementById(`steer-${taskId}`);
      if (!outputEl) return;

      const isExpanded = expandedTasks.has(taskId);
      if (isExpanded) {
        expandedTasks.delete(taskId);
        outputEl.classList.remove('visible');
        if (steerEl) steerEl.classList.remove('visible');
      } else {
        expandedTasks.add(taskId);
        outputEl.classList.add('visible');
        if (steerEl) steerEl.classList.add('visible');
        // Scroll to bottom
        outputEl.scrollTop = outputEl.scrollHeight;
      }
    }

    function appendOutput(taskId, chunk) {
      const outputEl = document.getElementById(`output-${taskId}`);
      if (!outputEl) return;

      // Get or create the chunk span
      let chunkEl = outputEl.querySelector('.chunk');
      if (!chunkEl) {
        outputEl.innerHTML = '<span class="chunk"></span>';
        chunkEl = outputEl.querySelector('.chunk');
      }
      chunkEl.textContent += chunk;

      // Auto-scroll if expanded
      if (expandedTasks.has(taskId)) {
        outputEl.scrollTop = outputEl.scrollHeight;
      }
    }

    function handleSteerKey(event, taskId) {
      if (event.key === 'Enter') {
        event.preventDefault();
        sendSteer(taskId);
      }
    }

    function sendSteer(taskId) {
      const steerEl = document.getElementById(`steer-${taskId}`);
      const input = steerEl?.querySelector('input');
      if (!input?.value || !ws) return;

      ws.send(JSON.stringify({ type: 'steer', taskId, input: input.value }));
      appendOutput(taskId, `\n> ${input.value}\n`);
      input.value = '';
    }

    function connectWebSocket() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws`);

      ws.onopen = () => {
        document.getElementById('statusDot').classList.remove('disconnected');
        document.getElementById('statusText').textContent = 'Connected';
      };

      ws.onclose = () => {
        document.getElementById('statusDot').classList.add('disconnected');
        document.getElementById('statusText').textContent = 'Disconnected';
        setTimeout(connectWebSocket, 3000);
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'tasks') {
          const list = document.getElementById('taskList');
          if (data.tasks.length === 0) {
            list.innerHTML = '<div class="empty">No tasks yet</div>';
          } else {
            list.innerHTML = data.tasks.map(renderTask).join('');
            // Restore expanded state
            expandedTasks.forEach(taskId => {
              const outputEl = document.getElementById(`output-${taskId}`);
              const steerEl = document.getElementById(`steer-${taskId}`);
              if (outputEl) {
                outputEl.classList.add('visible');
                outputEl.scrollTop = outputEl.scrollHeight;
              }
              if (steerEl) steerEl.classList.add('visible');
            });
          }
        } else if (data.type === 'output') {
          appendOutput(data.taskId, data.chunk);
        } else if (data.type === 'steerResult' && !data.success) {
          console.warn(`Failed to steer task ${data.taskId}`);
        }
      };
    }

    // Filter button handlers
    document.querySelectorAll('#workFilters .filter-btn').forEach(btn => {
      btn.addEventListener('click', () => setFilter(btn.dataset.filter));
    });

    // Initial load
    fetchPRs();
    fetchWorkItems();
    fetchResolvedByMe();
    fetchTasks();
    connectWebSocket();

    // Refresh every 2 minutes
    setInterval(refreshAll, 120000);
  </script>
</body>
</html>
