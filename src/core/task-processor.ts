import { Octokit } from 'octokit';
import { config } from './config.js';
import {
  getPendingTasks,
  getRunningCount,
  startTask,
  completeTask,
  failTask,
} from './task-queue.js';
import { runClaude, buildPromptForTask } from './claude-runner.js';
import {
  getGitStatus,
  getCurrentBranch,
  getDefaultBranch,
  createBranch,
  stageAndCommit,
  pushBranch,
  checkoutBranch,
  discardChanges,
  createGitHubPR,
  createAdoPR,
} from './git-ops.js';
import type { Task } from './types.js';

const octokit = new Octokit({ auth: config.github.token });

let onTaskUpdate: (() => void) | null = null;

export function setTaskUpdateCallback(callback: () => void): void {
  onTaskUpdate = callback;
}

function notifyUpdate(): void {
  onTaskUpdate?.();
}

export function triggerUpdate(): void {
  notifyUpdate();
}

async function postGitHubPrComment(repo: string, prNumber: number, body: string): Promise<void> {
  const [owner, repoName] = repo.split('/');
  await octokit.rest.issues.createComment({
    owner,
    repo: repoName,
    issue_number: prNumber,
    body,
  });
}

async function postAdoPrComment(repo: string, prNumber: number, body: string): Promise<void> {
  if (!config.ado.pat || !config.ado.organization) return;

  const [project, repoName] = repo.split('/');
  const url = `https://dev.azure.com/${config.ado.organization}/${project}/_apis/git/repositories/${repoName}/pullRequests/${prNumber}/threads?api-version=7.1`;

  const auth = Buffer.from(`:${config.ado.pat}`).toString('base64');

  await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Basic ${auth}`,
    },
    body: JSON.stringify({
      comments: [{ content: body, commentType: 1 }],
      status: 1, // Active
    }),
  });
}

async function postAdoWorkItemComment(workItemId: number, body: string): Promise<void> {
  if (!config.ado.pat || !config.ado.organization) return;

  const url = `https://dev.azure.com/${config.ado.organization}/_apis/wit/workItems/${workItemId}/comments?api-version=7.1-preview.4`;

  const auth = Buffer.from(`:${config.ado.pat}`).toString('base64');

  await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Basic ${auth}`,
    },
    body: JSON.stringify({ text: body }),
  });
}

function generateBranchName(task: Task): string {
  const prefix = task.type === 'issue-fix' ? 'bug' : task.type === 'code-gen' ? 'feat' : 'maintenance';
  const id = task.context.workItemId || task.context.issueNumber || task.id;
  const slug = (task.context.title || 'task')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .slice(0, 30)
    .replace(/-+$/, '');
  return `${prefix}/${id}-${slug}`;
}

async function handleCodeChanges(task: Task, output: string): Promise<string | null> {
  const status = getGitStatus(task.repoPath);

  if (!status.hasChanges) {
    console.log(`[Task #${task.id}] No code changes detected`);
    return null;
  }

  console.log(`[Task #${task.id}] Detected changes: ${status.unstaged.length + status.untracked.length} files`);

  const originalBranch = getCurrentBranch(task.repoPath);
  const defaultBranch = getDefaultBranch(task.repoPath);
  const newBranch = generateBranchName(task);

  // Create new branch
  if (!createBranch(task.repoPath, newBranch, defaultBranch)) {
    console.error(`[Task #${task.id}] Failed to create branch ${newBranch}`);
    discardChanges(task.repoPath);
    checkoutBranch(task.repoPath, originalBranch);
    return null;
  }

  // Commit changes
  const commitMsg = `${task.type}: ${task.context.title || 'Auto-generated changes'}\n\nGenerated by Orch task #${task.id}`;
  if (!stageAndCommit(task.repoPath, commitMsg)) {
    console.error(`[Task #${task.id}] Failed to commit`);
    discardChanges(task.repoPath);
    checkoutBranch(task.repoPath, originalBranch);
    return null;
  }

  // Push branch
  if (!pushBranch(task.repoPath, newBranch)) {
    console.error(`[Task #${task.id}] Failed to push branch`);
    checkoutBranch(task.repoPath, originalBranch);
    return null;
  }

  // Create PR
  const prTitle = `${task.type === 'issue-fix' ? 'Fix' : 'Feat'}: ${task.context.title || 'Auto-generated'}`;
  const prBody = `## Summary\n\nAuto-generated by Orch for task #${task.id}\n\n### Claude's Analysis\n\n${output.slice(0, 2000)}${output.length > 2000 ? '...' : ''}\n\n---\n_Generated by [Orch](https://github.com/orch)_`;

  let prUrl: string | null = null;

  if (task.context.source === 'github' || task.repo.split('/').length === 2) {
    prUrl = await createGitHubPR(task.repo, newBranch, defaultBranch, prTitle, prBody);
  } else if (task.context.source === 'ado') {
    const parts = task.repo.split('/');
    const project = parts.length === 3 ? parts[1] : parts[0];
    const repoName = parts[parts.length - 1];
    prUrl = await createAdoPR(project, repoName, newBranch, defaultBranch, prTitle, prBody);
  }

  // Return to original branch
  checkoutBranch(task.repoPath, originalBranch);

  if (prUrl) {
    console.log(`[Task #${task.id}] Created PR: ${prUrl}`);
  }

  return prUrl;
}

async function processTask(task: Task): Promise<void> {
  console.log(`Processing task #${task.id} (${task.type}) for ${task.repo}`);
  startTask(task.id);
  notifyUpdate();

  // Determine if this task type should allow code edits
  const allowEdits = ['issue-fix', 'code-gen', 'pipeline-fix'].includes(task.type);

  try {
    const prompt = buildPromptForTask(task);
    const result = await runClaude(task, prompt, { allowEdits });

    if (result.success) {
      let prUrl: string | null = null;

      // For edit tasks, check for code changes and create PR
      if (allowEdits) {
        prUrl = await handleCodeChanges(task, result.output);
      }

      // Build comment
      let comment = `## ü§ñ Claude ${task.type === 'pr-review' ? 'Code Review' : 'Analysis'}\n\n${result.output}`;
      if (prUrl) {
        comment += `\n\n---\nüìù **PR Created:** ${prUrl}`;
      }

      // Post result to GitHub
      if (task.context.source === 'github' && task.context.prNumber) {
        await postGitHubPrComment(task.repo, task.context.prNumber, comment);
      }

      // Post result to ADO
      if (task.context.source === 'ado') {
        if (task.context.prNumber) {
          await postAdoPrComment(task.repo, task.context.prNumber, comment);
        } else if (task.context.workItemId) {
          await postAdoWorkItemComment(task.context.workItemId, comment);
        }
      }

      const resultWithPr = prUrl ? `${result.output}\n\nPR: ${prUrl}` : result.output;
      completeTask(task.id, resultWithPr);
      console.log(`Task #${task.id} completed${prUrl ? ` (PR: ${prUrl})` : ''}`);
      notifyUpdate();
    } else {
      failTask(task.id, result.error || 'Unknown error');
      console.error(`Task #${task.id} failed:`, result.error);
      notifyUpdate();
    }
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    failTask(task.id, error);
    console.error(`Task #${task.id} error:`, error);
    notifyUpdate();
  }
}

export async function processQueue(): Promise<void> {
  const runningCount = getRunningCount();
  const available = config.claude.maxConcurrentTasks - runningCount;

  if (available <= 0) return;

  const pending = getPendingTasks(available);

  for (const task of pending) {
    // Don't await - run concurrently
    processTask(task).catch((err) => {
      console.error(`Unhandled error in task #${task.id}:`, err);
    });
  }
}

let intervalId: NodeJS.Timeout | null = null;

export function startProcessor(intervalMs = 5000): void {
  if (intervalId) return;
  console.log('Task processor started');
  intervalId = setInterval(() => {
    processQueue().catch(console.error);
  }, intervalMs);
  // Process immediately on start
  processQueue().catch(console.error);
}

export function stopProcessor(): void {
  if (intervalId) {
    clearInterval(intervalId);
    intervalId = null;
    console.log('Task processor stopped');
  }
}
